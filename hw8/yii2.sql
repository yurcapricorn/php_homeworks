-- phpMyAdmin SQL Dump
-- version 4.6.5.2
-- https://www.phpmyadmin.net/
--
-- Host: 127.0.0.1:3306
-- Generation Time: May 18, 2017 at 10:50 PM
-- Server version: 5.7.16
-- PHP Version: 7.1.0

SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
SET time_zone = "+00:00";


/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8mb4 */;

--
-- Database: `yii2`
--

-- --------------------------------------------------------

--
-- Table structure for table `article`
--

CREATE TABLE `article` (
  `id` int(11) NOT NULL,
  `title` varchar(255) DEFAULT NULL,
  `content` text,
  `image` varchar(255) DEFAULT NULL,
  `author_id` int(11) DEFAULT NULL,
  `category_id` int(11) DEFAULT '1'
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `article`
--

INSERT INTO `article` (`id`, `title`, `content`, `image`, `author_id`, `category_id`) VALUES
(1, 'Memento', 'Originator - \"Создатель\"\r\nCaretaker - \"Опекун\"\r\nMemento - \"Хранитель\"\r\nОписание\r\nКлассический вариант: Шаблон Хранитель используется двумя объектами: \"Создателем\" (originator) и \"Опекуном\" (caretaker). \"Создатель\" - это объект, у которого есть внутреннее состояние. Объект \"Опекун\" может производить некоторые действия с \"Создателем\", но при этом необходимо иметь возможность откатить изменения. Для этого \"Опекун\" запрашивает у \"Создателя\" объект \"Хранителя\". Затем выполняет запланированное действие (или последовательность действий). Для выполнения отката \"Создателя\" к состоянию, которое предшествовало изменениям, \"Опекун\" возвращает объект \"Хранителя\" его \"Создателю\". \"Хранитель\" является непрозрачным (т.е. таким, который не может или не должен изменяться \"Опекуном\").\r\n\r\nНестандартный вариант: Отличие данного варианта от классического заключено в более жёстком ограничении на доступ \"Опекуна\" к внутреннему состоянию \"Создателя\". В классическом варианте у \"Опекуна\" есть потенциальная возможность получить доступ к внутренним данным \"Создателя\" через \"Хранителя\", изменить состояние и установить его обратно \"Создателю\". В данном варианте \"Опекун\" обладает возможностью лишь восстановить состояние \"Хранителя\", вызвав Restore. Кроме всего прочего, \"Опекуну\" не требуется владеть связью на \"Хранителя\", чтобы восстановить его состояние. Это позволяет сохранять и восстанавливать состояние сложных иерархических или сетевых структур (состояния объектов и всех связей между ними) путём сбора снимков всех зарегистрированных объектов системы.', '8c90e2bf868042d1ca7f3e890f8070c5.png', 1, 3),
(2, 'Observer', 'Наблюдатель (англ. Observer) — поведенческий шаблон проектирования. Также известен как «подчинённые» (Dependents). Создает механизм у класса, который позволяет получать экземпляру объекта этого класса оповещения от других объектов об изменении их состояния, тем самым наблюдая за ними\r\n\r\nПохожие шаблоны: «издатель-подписчик», «посредник», «одиночка».\r\nНазначение\r\nОпределяет зависимость типа «один ко многим» между объектами таким образом, что при изменении состояния одного объекта все зависящие от него оповещаются об этом событии.\r\n\r\nПри реализации шаблона «наблюдатель» обычно используются следующие классы:\r\n\r\nObservable — интерфейс, определяющий методы для добавления, удаления и оповещения наблюдателей;\r\nObserver — интерфейс, с помощью которого наблюдатель получает оповещение;\r\nConcreteObservable — конкретный класс, который реализует интерфейс Observable;\r\nConcreteObserver — конкретный класс, который реализует интерфейс Observer.\r\nОбласть применения\r\nШаблон «наблюдатель» применяется в тех случаях, когда система обладает следующими свойствами:\r\n\r\nсуществует, как минимум, один объект, рассылающий сообщения;\r\nимеется не менее одного получателя сообщений, причём их количество и состав могут изменяться во время работы приложения;\r\nнет надобности очень сильно связывать взаимодействующие объекты, что полезно для повторного использования.\r\nДанный шаблон часто применяют в ситуациях, в которых отправителя сообщений не интересует, что делают получатели с предоставленной им информацией.', '0b1a436d6abc813d754320609ec0326c.png', 1, 3),
(3, 'Command', 'Команда (англ. Command) — поведенческий шаблон проектирования, используемый при объектно-ориентированном программировании, представляющий действие. Объект команды заключает в себе само действие и его параметры.\r\n\r\nЦель\r\nСоздание структуры, в которой класс-отправитель и класс-получатель не зависят друг от друга напрямую. Организация обратного вызова к классу, который включает в себя класс-отправитель.\r\n\r\nОписание\r\nВ объектно-ориентированном программировании шаблон проектирования Команда является поведенческим шаблоном, в котором объект используется для инкапсуляции всей информации, необходимой для выполнения действия или вызова события в более позднее время. Эта информация включает в себя имя метода, объект, который является владельцем метода и значения параметров метода.\r\n\r\nЧетыре термина всегда связанны с шаблоном Команда: команды (command), приёмник команд (receiver), вызывающий команды (invoker) и клиент (client). Объект Command знает о приёмнике и вызывает метод приемника. Значения параметров приёмника сохраняются в команде. Вызывающий объект (invoker) знает, как выполнить команду и, возможно, делает учёт и запись выполненных команд. Вызывающий объект (invoker) ничего не знает о конкретной команде, он знает только об интерфейсе. Оба объекта (вызывающий объект и несколько объектов команд) принадлежат объекту клиента (client). Клиент решает, какие команды выполнить и когда. Чтобы выполнить команду он передает объект команды вызывающему объекту (invoker).\r\n\r\nИспользование командных объектов упрощает построение общих компонентов, которые необходимо делегировать или выполнять вызовы методов в любое время без необходимости знать методы класса или параметров метода. Использование вызывающего объекта (invoker) позволяет ввести учёт выполненных команд без необходимости знать клиенту об этой модели учёта (такой учёт может пригодиться, например, для реализации отмены и повтора команд).\r\n\r\nПрименение\r\nШаблон Команда может быть полезен в следующих случаях.\r\n\r\nКнопки пользовательского интерфейса и пункты меню\r\nВ Swing и Borland Delphi Action (действие) является объектом команды. В дополнение к способности выполнить нужную команду, Action может иметь связанную с ним иконку, сочетание клавиш, текст всплывающей подсказки и так далее. Кнопка на панели инструментов или пункт меню могут быть полностью инициализированы с использованием только объекта Action.\r\n\r\nЗапись макросов\r\nЕсли все действия пользователя представлены в виде объектов команды, программа может записать последовательность действий, просто сохраняя список командных объектов в том порядке, в котором они выполняются. Затем она может «воспроизвести» одни и те же действия, выполняя те же объекты команд в той же последовательности.\r\n\r\nМногоуровневая отмена операций (Undo)\r\nЕсли все действия пользователя в программе реализованы в виде командных объектов, программа может сохранить стек последних выполненных команд. Когда пользователь хочет отменить команду, программа просто выталкивает последний объект команды и выполняет его метод undo().\r\n\r\nСети\r\nМожно отправить объекты команд по сети для выполнения на другой машине, например действие игрока в компьютерной игре.\r\n\r\nИндикаторы выполнения\r\nПредположим, что программа имеет последовательность команд, которые она выполняет по порядку. Если каждый объект команды имеет метод getEstimatedDuration() (получить оценочную длительность), программа может легко оценить общую продолжительность процесса. Она может показать индикатор выполнения, который отражает, насколько близка программа к завершению всех задач.\r\n\r\nПулы потоков\r\nТипичный класс пула потоков общего назначения может иметь метод addTask(), который добавляет рабочий элемент к внутренней очереди заданий ожидающих своего выполнения. Он поддерживает пул потоков, которые выполняют команды из очереди. Элементы в очереди являются объектами команд. Как правило, эти объекты реализуют общий интерфейс, такой как java.lang.Runnable, что позволяет пулу потоков запустить команды на выполнение, даже если он сам был написан без каких-либо знаний о конкретных задачах, для которых он будет использоваться.\r\n\r\nТранзакции\r\nАналогично операции «отмена» система управления базами данных (СУБД) или установщик программного обеспечения может хранить список операций, которые были или будут выполнены. Если одна из них закончится неудачей, то все остальные могут быть отменены или быть отброшены (обычно называется откат). Например, если две связанные между собой таблицы базы данных должны быть обновлены, а второе обновление терпит неудачу, то транзакция может быть откачена, чтобы первая таблица не содержала недопустимую ссылку.\r\n\r\nМастера\r\nЧасто мастер (мастер установки или любой другой) представляет несколько страниц конфигурации для одного действия, которое происходит только тогда, когда пользователь нажимает на кнопку «Готово» на последней странице. В этих случаях, естественный способ отделить код пользовательского интерфейса от кода приложения является реализация мастера с помощью объекта команд. Объект команда создается при первом отображении мастера. Каждая страница мастера сохраняет свои изменения в объекте команды, поэтому объект заполняется по мере перехода пользователя. Кнопка «Готово» просто запускает метод execute() на выполнение.', '761f01bb6764dfad92cd43e3b9099e5b.png', 1, 3),
(4, 'Abstract Factory', 'Абстрактная фабрика (англ. Abstract factory) — порождающий шаблон проектирования, предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов. Шаблон реализуется созданием абстрактного класса Factory, который представляет собой интерфейс для создания компонентов системы (например, для оконного интерфейса он может создавать окна и кнопки). Затем пишутся классы, реализующие этот интерфейс\r\n\r\nНазначение\r\nПредоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, не специфицируя их конкретных классов.\r\n\r\nПлюсы\r\nизолирует конкретные классы;\r\nупрощает замену семейств продуктов;\r\nгарантирует сочетаемость продуктов.\r\n\r\nМинусы\r\nсложно добавить поддержку нового вида продуктов.\r\n\r\nПрименение\r\nСистема не должна зависеть от того, как создаются, компонуются и представляются входящие в неё объекты.\r\nВходящие в семейство взаимосвязанные объекты должны использоваться вместе и вам необходимо обеспечить выполнение этого ограничения.\r\nСистема должна конфигурироваться одним из семейств составляющих её объектов.\r\nТребуется предоставить библиотеку объектов, раскрывая только их интерфейсы, но не реализацию.', 'ebafa425008d8bf80e52111bb8ada9de.jpg', 1, 1),
(5, 'State', 'Состояние (англ. State) — поведенческий шаблон проектирования. Используется в тех случаях, когда во время выполнения программы объект должен менять своё поведение в зависимости от своего состояния.\r\n\r\nПаттерн состоит из 3 блоков:\r\n\r\nWidget — класс, объекты которого должны менять своё поведение в зависимости от состояния.\r\n\r\nIState — интерфейс, который должен реализовать каждое из конкретных состояний. Через этот интерфейс объект Widget взаимодействует с состоянием, делегируя ему вызовы методов. Интерфейс должен содержать средства для обратной связи с объектом, поведение которого нужно изменить. Для этого используется событие (паттерн Publisher — Subscriber). Это необходимо для того, чтобы в процессе выполнения программы заменять объект состояния при появлении событий. Возможны случаи, когда сам Widget периодически опрашивает объект состояние на наличие перехода.\r\n\r\nStateA … StateZ — классы конкретных состояний. Должны содержать информацию о том, при каких условиях и в какие состояния может переходить объект из текущего состояния. Например, из StateA объект может переходить в состояние StateB и StateC, а из StateB — обратно в StateA и так далее. Объект одного из них должен содержать Widget при создании.', '5497a984dfdd61d39ca06c801bccbc77.png', 1, 3),
(6, 'Chain', 'Цепочка обязанностей (англ. Chain of responsibility) — поведенческий шаблон проектирования, предназначенный для организации в системе уровней ответственности.\r\n\r\nПрименение\r\nШаблон рекомендован для использования в условиях:\r\n\r\nв разрабатываемой системе имеется группа объектов, которые могут обрабатывать сообщения определенного типа;\r\nвсе сообщения должны быть обработаны хотя бы одним объектом системы;\r\nсообщения в системе обрабатываются по схеме «обработай сам либо перешли другому», то есть одни сообщения обрабатываются на том уровне, где они получены, а другие пересылаются объектам иного уровня.', '39e8b2bec46cb9efe9e453ca512aea74.png', 1, 3),
(7, 'Interpreter', 'Интерпретатор (англ. Interpreter) — поведенческий шаблон проектирования, решающий часто встречающуюся, но подверженную изменениям, задачу. Также известен как Little (Small) Language\r\n\r\nПроблема\r\nИмеется часто встречающаяся, подверженная изменениям задача.\r\n\r\nРешение\r\nСоздать интерпретатор, который решает данную задачу.\r\n\r\nПреимущества\r\nГрамматику становится легко расширять и изменять, реализации классов, описывающих узлы абстрактного синтаксического дерева похожи (легко кодируются). Можно легко изменять способ вычисления выражений.\r\n\r\nНедостатки\r\nСопровождение грамматики с большим числом правил затруднительно.\r\n\r\nПример\r\nЗадача поиска строк по образцу может быть решена посредством создания интерпретатора, определяющего грамматику языка. \"Клиент\" строит предложение в виде абстрактного синтаксического дерева, в узлах которого находятся объекты классов \"НетерминальноеВыражение\" и \"ТерминальноеВыражение\" (рекурсивное), затем \"Клиент\" инициализирует контекст и вызывает операцию Разобрать(Контекст). На каждом узле типа \"НетерминальноеВыражение\" определяется операция Разобрать для каждого подвыражения. Для класса \"ТерминальноеВыражение\" операция Разобрать определяет базу рекурсии. \"АбстрактноеВыражение\" определяет абстрактную операцию Разобрать, общую для всех узлов в абстрактном синтаксическом дереве. \"Контекст\" содержит информацию, глобальную по отношению к интерпретатору.', 'd3bed3a69e344f3bd01bcb0686924c23.png', 1, 3),
(8, 'Strategy', 'Стратегия (англ. Strategy) — поведенческий шаблон проектирования, предназначенный для определения семейства алгоритмов, инкапсуляции каждого из них и обеспечения их взаимозаменяемости. Это позволяет выбирать алгоритм путём определения соответствующего класса. Шаблон Strategy позволяет менять выбранный алгоритм независимо от объектов-клиентов, которые его используют.\r\n\r\nЗадача\r\nПо типу клиента (или по типу обрабатываемых данных) выбрать подходящий алгоритм, который следует применить. Если используется правило, которое не подвержено изменениям, нет необходимости обращаться к шаблону «стратегия».\r\n\r\nМотивы\r\nПрограмма должна обеспечивать различные варианты алгоритма или поведения\r\nНужно изменять поведение каждого экземпляра класса\r\nНеобходимо изменять поведение объектов на стадии выполнения\r\nВведение интерфейса позволяет классам-клиентам ничего не знать о классах, реализующих этот интерфейс и инкапсулирующих в себе конкретные алгоритмы\r\nСпособ решения\r\nОтделение процедуры выбора алгоритма от его реализации. Это позволяет сделать выбор на основании контекста.\r\n\r\nУчастники\r\nКласс Strategy определяет, как будут использоваться различные алгоритмы.\r\nКонкретные классы ConcreteStrategy реализуют эти различные алгоритмы.\r\nКласс Context использует конкретные классы ConcreteStrategy посредством ссылки на конкретный тип абстрактного класса Strategy. Классы Strategy и Context взаимодействуют с целью реализации выбранного алгоритма (в некоторых случаях классу Strategy требуется посылать запросы классу Context). Класс Context пересылает классу Strategy запрос, поступивший от его класса-клиента.\r\nСледствия\r\nШаблон Strategy определяет семейство алгоритмов.\r\nЭто позволяет отказаться от использования переключателей и/или условных операторов.\r\nВызов всех алгоритмов должен осуществляться стандартным образом (все они должны иметь одинаковый интерфейс).\r\nРеализация\r\nКласс, который использует алгоритм (Context), включает абстрактный класс (Strategy), обладающий абстрактным методом, определяющим способ вызова алгоритма. Каждый производный класс реализует один требуемый вариант алгоритма.\r\n\r\nЗамечание: метод вызова алгоритма не должен быть абстрактным, если требуется реализовать некоторое поведение, принимаемое по умолчанию.\r\n\r\nПолезные сведения\r\nи стратегия, и декоратор могут применяться для изменения поведения конкретных классов. Достоинство стратегии в том, что интерфейс кастомизации не совпадает с публичным интерфейсом и может быть куда более удобным, а недостаток в том, что для использования стратегии необходимо изначально проектировать класс с возможностью регистрации стратегий.\r\nИспользование\r\nАрхитектура Microsoft WDF основана на этом паттерне. У каждого объекта «драйвер» и «устройство» есть неизменяемая часть, вшитая в систему, в которой регистрируется изменяемая часть (стратегия), написанная в конкретной реализации. Изменяемая часть может быть и вовсе пустой, что даст ничего не делающий драйвер, но при этом способный участвовать в PnP и управлении питанием.\r\n\r\nБиблиотека ATL содержит в себе набор классов threading model, которые являются стратегиями (различными реализациями Lock/Unlock, которые потом используются основными классами системы). При этом в этих стратегиях используется статический полиморфизм через параметр шаблона, а не динамический полиморфизм через виртуальные методы.', '5bbc1cd07532a4036284a8f248bdbf89.png', 1, 3),
(9, 'Iterator', 'Iterator — поведенческий шаблон проектирования. Представляет собой объект, позволяющий получить последовательный доступ к элементам объекта-агрегата без использования описаний каждого из агрегированных объектов.\r\n\r\nНапример, такие элементы как дерево, связанный список, хэш-таблица и массив могут быть пролистаны (и модифицированы) с помощью объекта Итератор.\r\n\r\nПеребор элементов выполняется объектом итератора, а не самой коллекцией. Это упрощает интерфейс и реализацию коллекции, а также способствует более логичному разделению обязанностей.\r\n\r\nОсобенностью полноценно реализованного итератора является то, что код, использующий итератор, может ничего не знать о типе итерируемого агрегата.\r\n\r\nКонечно же, (в С++) почти в любом агрегате можно выполнять итерации указателем void*, но при этом:\r\n\r\nне ясно, что является значением «конец агрегата», для двусвязного списка это &ListHead, для массива это &array[size], для односвязного списка это NULL\r\nоперация Next сильно зависит от типа агрегата.\r\nИтераторы позволяют абстрагироваться от типа и признака окончания агрегата, используя полиморфный Next (часто реализованный как operator++ в С++) и полиморфный aggregate.end(), возвращающий значение «конец агрегата».\r\n\r\nТаким образом, появляется возможность работы с диапазонами итераторов, при отсутствии знания о типе итерируемого агрегата.', 'c131bbe51f8efc12c2dfdaf1ab5a4be0.png', 1, 3),
(10, 'Template Method', 'Шаблонный метод (англ. Template method) — поведенческий шаблон проектирования, определяющий основу алгоритма и позволяющий наследникам переопределять некоторые шаги алгоритма, не изменяя его структуру в целом.\r\n\r\nПрименимость\r\nОднократное использование инвариантной части алгоритма, с оставлением изменяющейся части на усмотрение наследникам.\r\nЛокализация и вычленение общего для нескольких классов кода для избегания дублирования.\r\nРазрешение расширения кода наследниками только в определенных местах.\r\nУчастники\r\nAbstract class (абстрактный класс) - определяет абстрактные операции, замещаемые в наследниках для реализации шагов алгоритма; реализует шаблонный метод, определяющий скелет алгоритма. Шаблонный метод вызывает замещаемые и другие, определенные в Abstract class, операции.\r\n\r\nConcrete class (конкретный класс) - реализует замещаемые операции необходимым для данной реализации способом.\r\n\r\nConcrete class предполагает, что инвариантные шаги алгоритма будут выполнены в AbstractClass.', '9fcfca16dec15dfb6198ba5e7c281bb4.png', 1, 3),
(11, 'Visitor', 'Посетитель (англ. visitor) — поведенческий шаблон проектирования, описывающий операцию, которая выполняется над объектами других классов. При изменении visitor нет необходимости изменять обслуживаемые классы.\r\n\r\nШаблон демонстрирует классический приём восстановления информации о потерянных типах, не прибегая к понижающему приведению типов.\r\n\r\nРешаемая проблема\r\nНеобходимо сделать какие-то несвязные операции над рядом объектов, но нужно избежать загрязнения их кода. И нет возможности или желания запрашивать тип каждого узла и осуществлять приведение указателя к правильному типу, прежде чем выполнить нужную операцию.\r\n\r\nЗадача\r\nНад каждым объектом некоторой структуры выполняется одна или более операций. Нужно определить новую операцию, не изменяя классы объектов.\r\n\r\nРешение\r\nДля независимости посетитель имеет отдельную иерархию. Структуры имеют некий интерфейс взаимодействия.\r\n\r\nИспользование\r\nЕсли есть вероятность изменения иерархии обслуживаемого класса, либо она будет нестабильной или открытый интерфейс достаточно эффективен для доступа шаблона, то его использование будет вредоносным.\r\nСоздается базовый класс Visitor с методами visit() для каждого подкласса родительского Element. Добавьте метод accept(visitor) в иерархию Element. Для каждой операции, которая должна выполняться для объектов Element, создайте производный от Visitor класс. Реализации метода visit() должны использовать открытый интерфейс класса Element. В результате: клиенты создают объекты Visitor и передают их каждому объекту Element, вызывая accept().\r\n\r\nШаблон следует использовать, если:\r\nимеются различные объекты разных классов с разными интерфейсами, но над ними нужно совершать операции, зависящие от конкретных классов;\r\nнеобходимо над структурой выполнить различные, усложняющие структуру операции;\r\nчасто добавляются новые операции над структурой.\r\n\r\nПреимущества:\r\nупрощается добавление новых операций;\r\nобъединение родственных операции в классе Visitor;\r\nкласс Visitor может запоминать в себе какое-то состояние по ходу обхода контейнера.\r\n\r\nНедостатки:\r\nзатруднено добавление новых классов, поскольку нужно обновлять иерархию посетителя и его сыновей.\r\n\r\nРеализация\r\nДобавьте метод accept(Visitor) в иерархию «элемент».\r\nСоздайте базовый класс Visitor и определите методы visit() для каждого типа элемента.\r\nСоздайте производные классы Visitor для каждой операции, исполняемой над элементами.\r\nКлиент создаёт объект Visitor и передаёт его в вызываемый метод accept().', '9dd23c482c619b9baf02fe053e5d9fb8.png', 1, 3),
(12, 'Mediator', 'Посредник (англ. Mediator) — поведенческий шаблон проектирования, обеспечивающий взаимодействие множества объектов, формируя при этом слабую связанность и избавляя объекты от необходимости явно ссылаться друг на друга.\r\n\r\nПроблема\r\nОбеспечить взаимодействие множества объектов, сформировав при этом слабую связанность и избавив объекты от необходимости явно ссылаться друг на друга.\r\n\r\nРешение\r\nСоздать объект, инкапсулирующий способ взаимодействия множества объектов.\r\n\r\nПреимущества\r\nУстраняется связанность между \"Коллегами\", централизуется управление.\r\n\r\n\"Посредник\" определяет интерфейс для обмена информацией с объектами \"Коллеги\", \"Конкретный посредник\" координирует действия объектов \"Коллеги\". Каждый класс \"Коллеги\" знает о своем объекте \"Посредник\", все \"Коллеги\" обмениваются информацией только с посредником, при его отсутствии им пришлось бы обмениваться информацией напрямую. \"Коллеги\" посылают запросы посреднику и получают запросы от него. \"Посредник\" реализует кооперативное поведение, пересылая каждый запрос одному или нескольким \"Коллегам\".', '08461ada04495de8d3b457788cd0a933.png', 1, 3),
(13, 'Adapter', 'Адаптер (англ. Adapter) — структурный шаблон проектирования, предназначенный для организации использования функций объекта, недоступного для модификации, через специально созданный интерфейс.\r\n\r\nОсновные характеристики\r\nЗадача\r\nСистема поддерживает требуемые данные и поведение, но имеет неподходящий интерфейс.\r\n\r\nСпособ решения\r\nАдаптер предусматривает создание класса-оболочки с требуемым интерфейсом.\r\n\r\nУчастники\r\nКласс Adapter приводит интерфейс класса Adaptee в соответствие с интерфейсом класса Target (наследником которого является Adapter). Это позволяет объекту Client использовать объект Adaptee (посредством адаптера Adapter) так, словно он является экземпляром класса Target.\r\n\r\nТаким образом Client обращается к интерфейсу Target, реализованному в наследнике Adapter, который перенаправляет обращение к Adaptee.\r\n\r\nСледствия\r\nШаблон Адаптер позволяет включать уже существующие объекты в новые объектные структуры, независимо от различий в их интерфейсах.\r\n\r\nЗамечания и комментарии\r\nШаблон Адаптер позволяет в процессе проектирования не принимать во внимание возможные различия в интерфейсах уже существующих классов. Если есть класс, обладающий требуемыми методами и свойствами (по крайней мере, концептуально), то при необходимости всегда можно воспользоваться шаблоном Адаптер для приведения его интерфейса к нужному виду.\r\n\r\nБлизким Адаптеру является шаблон Фасад, не всегда можно отличить один от другого\r\n\r\nПрименение шаблона\r\nТипичным примером использования шаблона Адаптер можно назвать создание классов, приводящих к единому интерфейсу функции языка PHP обеспечивающие доступ к различным СУБД', '8253c247cf07051c502b4d649b723339.png', 1, 2),
(14, 'Proxy', 'Заместитель (англ. Proxy) — структурный шаблон проектирования, который предоставляет объект, который контролирует доступ к другому объекту, перехватывая все вызовы (выполняет функцию контейнера).\r\n\r\nПроблема\r\nНеобходимо контролировать доступ к объекту, не изменяя при этом поведение клиента. \r\n\r\nНеобходимо иметь доступ к объекту так, чтобы не создавать реальные объекты непосредственно, а через другой объект, который может иметь дополнительную функциональность.\r\n\r\nРешение\r\nСоздать суррогат реального объекта. «Заместитель» хранит ссылку, которая позволяет заместителю обратиться к реальному субъекту (объект класса «Заместитель» может обращаться к объекту класса «Субъект», если интерфейсы «Реального Субъекта» и «Субъекта» одинаковы). Поскольку интерфейс «Реального Субъекта» идентичен интерфейсу «Субъекта», так, что «Заместителя» можно подставить вместо «Реального Субъекта», контролирует доступ к «Реальному Субъекту», может отвечать за создание или удаление «Реального Субъекта». «Субъект» определяет общий для «Реального Субъекта» и «Заместителя» интерфейс так, что «Заместитель» может быть использован везде, где ожидается «Реальный Субъект». При необходимости запросы могут быть переадресованы «Заместителем» «Реальному Субъекту».\r\n\r\nВиды\r\nПротоколирующий прокси: сохраняет в лог все вызовы «Субъекта» с их параметрами.\r\nУдалённый заместитель (англ. remote proxies): обеспечивает связь с «Субъектом», который находится в другом адресном пространстве или на удалённой машине. Также может отвечать за кодирование запроса и его аргументов и отправку закодированного запроса реальному «Субъекту»,\r\nВиртуальный заместитель (англ. virtual proxies): обеспечивает создание реального «Субъекта» только тогда, когда он действительно понадобится. Также может кэшировать часть информации о реальном «Субъекте», чтобы отложить его создание,\r\nКопировать-при-записи: обеспечивает копирование «субъекта» при выполнении клиентом определённых действий (частный случай «виртуального прокси»).\r\nЗащищающий заместитель (англ. protection proxies): может проверять, имеет ли вызывающий объект необходимые для выполнения запроса права.\r\nКэширующий прокси: обеспечивает временное хранение результатов расчёта до отдачи их множественным клиентам, которые могут разделить эти результаты.\r\nЭкранирующий прокси: защищает «Субъект» от опасных клиентов (или наоборот).\r\nСинхронизирующий прокси: производит синхронизированный контроль доступа к «Субъекту» в асинхронной многопоточной среде.\r\n«Умная» ссылка (англ. smart reference proxy): производит дополнительные действия, когда на «Субъект» создается ссылка, например, рассчитывает количество активных ссылок на «Субъект».\r\n\r\nПреимущества\r\nудалённый заместитель;\r\nвиртуальный заместитель может выполнять оптимизацию;\r\nзащищающий заместитель;\r\n«умная» ссылка(указатель);\r\nНедостатки\r\nрезкое увеличение времени отклика.\r\n\r\nСфера применения\r\nШаблон Proxy может применяться в случаях работы с сетевым соединением, с огромным объектом в памяти (или на диске) или с любым другим ресурсом, который сложно или тяжело копировать. Хорошо известный пример применения — объект, подсчитывающий число ссылок.\r\n\r\nПрокси и близкие к нему шаблоны\r\nАдаптер обеспечивает отличающийся интерфейс к объекту.\r\nПрокси обеспечивает тот же самый интерфейс.\r\nДекоратор обеспечивает расширенный интерфейс.', '9cb9a5676d28fa716e4ca7bc8cbffd9e.png', 1, 2),
(16, 'Bridge', 'Шаблон мост (англ. Bridge) — структурный шаблон проектирования, используемый в проектировании программного обеспечения чтобы «разделять абстракцию и реализацию так, чтобы они могли изменяться независимо». Шаблон мост использует инкапсуляцию, агрегирование и может использовать наследование для того, чтобы разделить ответственность между классами.\r\n\r\nЦель\r\nПри частом изменении класса преимущества объектно-ориентированного подхода становятся очень полезными, позволяя делать изменения в программе, обладая минимальными сведениями о реализации программы. Шаблон bridge является полезным там, где часто меняется не только сам класс, но и то, что он делает.\r\n\r\nОписание\r\nКогда абстракция и реализация разделены, они могут изменяться независимо. Другими словами, при реализации через шаблон мост, изменение структуры интерфейса не мешает изменению структуры реализации. Рассмотрим такую абстракцию как фигура. Существует множество типов фигур, каждая со своими свойствами и методами. Однако есть что-то, что объединяет все фигуры. Например, каждая фигура должна уметь рисовать себя, масштабироваться и т. п. В то же время рисование графики может отличаться в зависимости от типа ОС, или графической библиотеки. Фигуры должны иметь возможность рисовать себя в различных графических средах, но реализовывать в каждой фигуре все способы рисования или модифицировать фигуру каждый раз при изменении способа рисования непрактично. В этом случае помогает шаблон мост, позволяя создавать новые классы, которые будут реализовывать рисование в различных графических средах. При использовании такого подхода очень легко можно добавлять как новые фигуры, так и способы их рисования.\r\n\r\nСвязь, изображаемая стрелкой на диаграммах, может иметь 2 смысла: а) «разновидность», в соответствии с принципом подстановки Б. Лисков и б) одна из возможных реализаций абстракции. Обычно в языках используется наследование для реализации как а), так и б), что приводит к разбуханию иерархий классов.\r\n\r\nМост служит именно для решения этой проблемы: объекты создаются парами из объекта класса иерархии А и иерархии B, наследование внутри иерархии А имеет смысл «разновидность» по Лисков, а для понятия «реализация абстракции» используется ссылка из объекта A в парный ему объект B.\r\n\r\nИспользование\r\nАрхитектура Java AWT полностью основана на этом шаблоне — иерархия java.awt.xxx для хэндлов и sun.awt.xxx для реализаций.', '68a1171561039fc2bc82a5721d74af3a.png', 1, 2),
(18, 'Composite', 'Компоновщик (англ. Composite pattern) — структурный шаблон проектирования, объединяющий объекты в древовидную структуру для представления иерархии от частного к целому. Компоновщик позволяет клиентам обращаться к отдельным объектам и к группам объектов одинаково.\r\n\r\nЦель\r\nПаттерн определяет иерархию классов, которые одновременно могут состоять из примитивных и сложных объектов, упрощает архитектуру клиента, делает процесс добавления новых видов объекта более простым.', '68091f3afbdb0ec431b25bff4413a420.png', 1, 2),
(19, 'Builder', 'Строитель (англ. Builder) — порождающий шаблон проектирования предоставляет способ создания составного объекта.\r\n\r\nЦель\r\nОтделяет конструирование сложного объекта от его представления, так что в результате одного и того же процесса конструирования могут получаться разные представления.\r\n\r\nПлюсы\r\nпозволяет изменять внутреннее представление продукта;\r\nизолирует код, реализующий конструирование и представление;\r\nдает более тонкий контроль над процессом конструирования.\r\n\r\nПрименение\r\nалгоритм создания сложного объекта не должен зависеть от того, из каких частей состоит объект и как они стыкуются между собой;\r\nпроцесс конструирования должен обеспечивать различные представления конструируемого объекта.\r\n\r\nПрименение\r\nОбъекты «моникер» в COM есть Строители, инициализируемые строкой. Более того, для их создания используется другой Строитель — MkParseDisplayNameEx, который определяет по строке класс моникера, создает моникер и инициализирует его этой же строкой.\r\n\r\nОдин из этих объектов, URL Moniker, используется для всей загрузки страниц, вложений и документов в Microsoft Internet Explorer.', '65161b0e9002c7e28980187f583a7a3b.png', 1, 1),
(20, 'Decorator', 'Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.\r\n\r\nЗадача\r\nОбъект, который предполагается использовать, выполняет основные функции. Однако может потребоваться добавить к нему некоторую дополнительную функциональность, которая будет выполняться до, после или даже вместо основной функциональности объекта.\r\n\r\nСпособ решения\r\nДекоратор предусматривает расширение функциональности объекта без определения подклассов.\r\n\r\nУчастники\r\nКласс ConcreteComponent — класс, в который с помощью шаблона Декоратор добавляется новая функциональность. В некоторых случаях базовая функциональность предоставляется классами, производными от класса ConcreteComponent. В подобных случаях класс ConcreteComponent является уже не конкретным, а абстрактным. Абстрактный класс Component определяет интерфейс для использования всех этих классов.\r\n\r\nСледствия\r\nДобавляемая функциональность реализуется в небольших объектах. Преимущество состоит в возможности динамически добавлять эту функциональность до или после основной функциональности объекта ConcreteComponent.\r\nПозволяет избегать перегрузки функциональными классами на верхних уровнях иерархии\r\nДекоратор и его компоненты не являются идентичными\r\nРеализация\r\n\r\nСоздается абстрактный класс, представляющий как исходный класс, так и новые, добавляемые в класс функции. В классах-декораторах новые функции вызываются в требуемой последовательности — до или после вызова последующего объекта.\r\n\r\nПри желании остаётся возможность использовать исходный класс (без расширения функциональности), если на его объект сохранилась ссылка.\r\n\r\nХотя объект-декоратор может добавлять свою функциональность до или после функциональности основного объекта, цепочка создаваемых объектов всегда должна заканчиваться объектом класса ConcreteComponent.\r\nБазовые классы языка Java широко используют шаблон Декоратор для организации обработки операций ввода-вывода.\r\nИ декоратор, и адаптер являются обёртками вокруг объекта — хранят в себе ссылку на оборачиваемый объект и часто передают в него вызовы методов. Отличие декоратора от адаптера в том, что адаптер имеет внешний интерфейс, отличный от интерфейса оборачиваемого объекта, и используется именно для стыковки разных интерфейсов. Декоратор же имеет точно такой же интерфейс, и используется для добавления функциональности.\r\nДля расширения функциональности класса возможно использовать как декораторы, так и стратегии. Декораторы оборачивают объект снаружи, стратегии же вставляются в него внутрь по неким интерфейсам.\r\nНедостаток стратегии: класс должен быть спроектирован с возможностью вставления стратегий, декоратор же не требует такой поддержки.\r\nНедостаток декоратора: он оборачивает ровно тот же интерфейс, что предназначен для внешнего мира, что вызывает смешение публичного интерфейса и интерфейса кастомизации, которое не всегда желательно.\r\n\r\nПрименение шаблона\r\nДрайверы-фильтры в ядре Windows (архитектура WDM (Windows Driver Model)) представляют собой декораторы. Несмотря на то, что WDM реализована на не-объектном языке Си, в ней четко прослеживаются паттерны проектирования — декоратор, цепочка обязанностей, и команда (объект IRP).\r\n\r\nАрхитектура COM (Component Object Model) не поддерживает наследование реализаций, вместо него предлагается использовать декораторы (в данной архитектуре это называется «агрегация»). При этом архитектура решает (с помощью механизма pUnkOuter) проблему object identity, возникающую при использовании декораторов — identity агрегата есть identity его самого внешнего декоратора.', 'd3499c36a7a12857b60eb21df49547b5.png', 1, 2),
(21, 'Prototype', 'Прототип, (англ. Prototype) — порождающий шаблон проектирования.\r\n\r\nНазначение\r\nЗадаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа. Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы». В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.\r\n\r\nПроще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.\r\n\r\nПаттерн используется чтобы:\r\nизбежать дополнительных усилий по созданию объекта стандартным путём (имеется в виду использование конструктора, так как в этом случае также будут вызваны конструкторы всей иерархии предков объекта), когда это непозволительно дорого для приложения.\r\nизбежать наследования создателя объекта (object creator) в клиентском приложении, как это делает паттерн abstract factory.\r\nИспользуйте этот шаблон проектирования, когда системe безразлично как именно в ней создаются, компонуются и представляются продукты:\r\n\r\nинстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;\r\nизбежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;\r\nэкземпляры класса могут находиться в одном из нескольких различных состояний. Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.', '9f1371f738141c708bfc852d753b4ed1.png', 1, 1),
(22, 'Factory Method', 'Фабричный метод (англ. Factory Method также известен как Виртуальный конструктор (англ. Virtual Constructor)) — порождающий шаблон проектирования, предоставляющий подклассам интерфейс для создания экземпляров некоторого класса. В момент создания наследники могут определить, какой класс создавать. Иными словами, Фабрика делегирует создание объектов наследникам родительского класса. Это позволяет использовать в коде программы не специфические классы, а манипулировать абстрактными объектами на более высоком уровне.\r\n\r\nЦель\r\nОпределяет интерфейс для создания объекта, но оставляет подклассам решение о том, какой класс инстанцировать. Фабричный метод позволяет классу делегировать создание подклассов. Используется, когда:\r\nклассу заранее неизвестно, объекты каких подклассов ему нужно создавать.\r\nкласс спроектирован так, чтобы объекты, которые он создаёт, специфицировались подклассами.\r\nкласс делегирует свои обязанности одному из нескольких вспомогательных подклассов, и планируется локализовать знание о том, какой класс принимает эти обязанности на себя\r\n\r\nСтруктура\r\nProduct — продукт\r\nопределяет интерфейс объектов, создаваемых абстрактным методом;\r\nConcreteProduct — конкретный продукт\r\nреализует интерфейс Product;\r\nCreator — создатель\r\nобъявляет фабричный метод, который возвращает объект типа Product. Может также содержать реализацию этого метода «по умолчанию»;\r\nможет вызывать фабричный метод для создания объекта типа Product;\r\nConcreteCreator — конкретный создатель\r\nпереопределяет фабричный метод таким образом, чтобы он создавал и возвращал объект класса ConcreteProduct.\r\nДостоинства\r\nпозволяет сделать код создания объектов более универсальным, не привязываясь к конкретным классам (ConcreteProduct), а оперируя лишь общим интерфейсом (Product);\r\nпозволяет установить связь между параллельными иерархиями классов.\r\nНедостатки\r\nнеобходимость создавать наследника Creator для каждого нового типа продукта (ConcreteProduct).', '9d0092f753cc45a05e4d4122b0ecaa8a.png', 1, 1),
(23, 'Facade', 'Шаблон фасад (англ. Facade) — структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту, делегирующему их соответствующим объектам системы.\r\n\r\nПроблема\r\nКак обеспечить унифицированный интерфейс с набором разрозненных реализаций или интерфейсов, например, с подсистемой, если нежелательно высокое связывание с этой подсистемой или реализация подсистемы может измениться?\r\n\r\nРешение\r\nОпределить одну точку взаимодействия с подсистемой — фасадный объект, обеспечивающий общий интерфейс с подсистемой, и возложить на него обязанность по взаимодействию с её компонентами. Фасад — это внешний объект, обеспечивающий единственную точку входа для служб подсистемы. Реализация других компонентов подсистемы закрыта и не видна внешним компонентам. Фасадный объект обеспечивает реализацию GRASP паттерна Устойчивый к изменениям (Protected Variations) с точки зрения защиты от изменений в реализации подсистемы.\r\n\r\nОсобенности применения\r\nШаблон применяется для установки некоторого рода политики по отношению к другой группе объектов. Если политика должна быть яркой и заметной, следует воспользоваться услугами шаблона Фасад. Если же необходимо обеспечить скрытность и аккуратность (прозрачность), более подходящим выбором является шаблон Заместитель (Proxy).', 'c5d2e144f09b3c03184700b0bb186faa.png', 1, 2),
(24, 'Flyweight', 'Приспособленец (англ. Flyweight, \"легковесный (элемент)\") — структурный шаблон проектирования, при котором объект, представляющий себя как уникальный экземпляр в разных местах программы, по факту не является таковым.\r\n\r\nЦель\r\nОптимизация работы с памятью путём предотвращения создания экземпляров элементов, имеющих общую сущность.\r\n\r\nОписание\r\nFlyweight используется для уменьшения затрат при работе с большим количеством мелких объектов. При проектировании приспособленца необходимо разделить его свойства на внешние и внутренние. Внутренние свойства всегда неизменны, тогда как внешние могут отличаться в зависимости от места и контекста применения и должны быть вынесены за пределы приспособленца.\r\n\r\nFlyweight дополняет шаблон Factory Method таким образом, что при обращении клиента к Factory Method для создания нового объекта ищет уже созданный объект с такими же параметрами, что и у требуемого, и возвращает его клиенту. Если такого объекта нет, то фабрика создаст новый.', '0c5c880182b1d3cfc96d0e07b24ac43e.png', 1, 2),
(25, 'Singleton', 'Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопроцессном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру.\r\n\r\nУ класса есть только один экземпляр, и он предоставляет к нему глобальную точку доступа. Существенно то, что можно пользоваться именно экземпляром класса, так как при этом во многих случаях становится доступной более широкая функциональность. Например, к описанным компонентам класса можно обращаться через интерфейс, если такая возможность поддерживается языком.\r\n\r\nГлобальный «одинокий» объект — именно объект, а не набор процедур, не привязанных ни к какому объекту — бывает нужен:\r\n\r\nесли используется существующая объектно-ориентированная библиотека;\r\nесли есть шансы, что один объект когда-нибудь превратится в несколько;\r\nесли интерфейс объекта (например, игрового мира) слишком сложен и не стоит засорять основное пространство имён большим количеством функций;\r\nесли, в зависимости от каких-нибудь условий и настроек, создаётся один из нескольких объектов. Например, в зависимости от того, ведётся лог или нет, создаётся или настоящий объект, пишущий в файл, или «заглушка», ничего не делающая.\r\nТакие объекты можно создавать и при инициализации программы. Это может приводить к следующим трудностям:\r\n\r\nЕсли объект нужен уже при инициализации, он может быть затребован раньше, чем будет создан.\r\nБывает, что объект нужен не всегда. В таком случае его создание можно пропустить.\r\n\r\nПлюсы\r\nконтролируемый доступ к единственному экземпляру.\r\n\r\nМинусы\r\nглобальные объекты могут быть вредны для объектного программирования, в некоторых случаях приводят к созданию немасштабируемого проекта;\r\nусложняет написание модульных тестов и следование TDD.\r\n\r\nПрименение\r\nдолжен быть ровно один экземпляр некоторого класса, легко доступный всем клиентам;\r\nединственный экземпляр должен расширяться путём порождения подклассов, и клиентам нужно иметь возможность работать с расширенным экземпляром без модификации своего кода.\r\n\r\nПримеры использования\r\nВедение отладочного файла для приложения.', '10efcd6bad2c111b6f21f51d2eec770f.png', 1, 1),
(26, 'Information Expert', 'Проблема<br>	В системе должна аккумулироваться, рассчитываться и т. п. необходимая информация.\r\nРешение<br>	Назначить обязанность аккумуляции информации, расчета и т. п. некоему классу (информационному эксперту), обладающему необходимой информацией.\r\nРекомендации<br>	Информационным экспертом может быть не один класс, а несколько.\r\nПример<br>	Необходимо рассчитать общую сумму продажи. Имеются классы проектирования \"Продажа\", \"ТоварПродажа\" (продажа отдельного вида товара в рамках продажи в целом), \"ТоварСпецификация\" (описание конкретного вида товара).\r\nНеобходимо распределить обязанности по предоставлению информации и расчету между этими классами. Объект \"Продажа\" должен передать сообщение \"Рассчитать промежуточную сумму\" каждому экземпляру класса \"ТоварПродажа\" (которые, в свою очередь, передают сообщения \"СообщитьЦену\" объектам \"ТоварСпецификация\", с целью получения информации о цене экземпляра товара), и, затем, просуммировать полученные результаты. Промежуточную сумму рассчитывает объект \"Товар Продажа\". Таким образом, все три объекта являются информационными экспертами.\r\nПреимущества<br>	Поддерживает инкапсуляцию, то есть объекты используют свои собственные данные для выполнения поставленных задач.\r\nНедостатки<br>	Если объект, обладающий наиболее полной информацией, например, о продаже (см. пример - класс \"Продажа\"), будет отвечать и за сохранение этой информации в базе данных, то получится, что логика приложения (моделирование продажи) и логика связи с базой данных \"помещаются\" в один класс (нарушение принципа разделения обязанностей основных объектов системы, и, кроме того, логика связи с базой данных будет дублироваться во многих других классах.', '74422ebe3f0ffbff983adbff7fc351aa.gif', 2, 2),
(27, 'Creator', 'Проблема<br>\r\n\"Кто\" должен отвечать за создание экземпляров класса.\r\nРешение<br>\r\nНазначить классу В обязанность создавать объекты другого класса А\r\nРекомендации<br>\r\nЛогично использовать паттерн если класс В содержит, агрегирует, активно использует и т.п. объекты класса А.\r\nнеобходимо определить, какой объект должен отвечать за создание экземпляра \"ТоварПродажа\". Логично, чтобы это был объект \"Продажа\", поскольку он содержит (агрегирует) несколько обьектов \"ТоварПродажа\".\r\nПреимущества<br>\r\nИспользование этого паттерна не повышает связанности, поскольку созданный класс, как правило, виден только для класса - создателя.\r\nНедостатки<br>\r\nЕсли процедура создания объекта достаточно сложная (например выполняется на основе некоего внешнего условия), логично использовать паттерн \"Абстрактная Фабрика\", см. 3.3.1, то есть, делегировать обязанность создания обьектов специальному классу.', '7783d5025a9452b016481cca049ff1a0.gif', 2, 1),
(28, 'Pure Fabrication', 'Проблема<br>	Какой класс должен обеспечивать реализацию паттернов \"Высокое зацепление\" 3.2.13, и \"Низкая связанность\" 3.1.7?\r\nРешение<br>	Присвоить группу обязанностей с высокой степенью зацепления классу, который не представляет конкретного понятия из предметной области (синтезировать искусственную сущность для обеспечения высокого зацепления и слабого связывания).\r\nПример<br> Какой класс должен сохранять экземпляры класса \"Продажа\" в реляционной базе данных? Если возложить эту обязанность на класс \"Продажа\", то будем иметь низкую степень зацепления и высокую степень связывания (поскольку класс \"Продажа\" должен быть связан с интерфейсом реляционной базы данных. Хранение обьектов в реляционной базе данных - это общая задача, которую придется решать для многих классов. Решением данной проблемы будет создание нового класса \"ПостоянноеХранилище\", ответственного за сохранение обьектов некоторого вида в базе данных.\r\nПреимущества<br>	Класс \"ПостоянноеХранилище\" будет обладать низкой степенью связывания и высокой степенью зацепления.\r\nНедостатки<br>	Данным паттерном не следует злоупотреблять иначе все функции системы превратятся в объекты.', '835d3e3493f0b82f64e589d141404dbd.jpg', 2, 3),
(29, 'Low Coupling', 'Проблема<br>	Обеспечить низкую связанность при создании экземпляра класса и связывании его с другим классом.\r\n<br>Решение<br>	Распределить обязанности между объектами так, чтобы степень связанности оставалась низкой.\r\n<br>Пример<br>	Необходимо создать экземпляр класса \"Платеж\". В предметной области регистрация объекта \"Платеж\" выполняется объектом \"Регистрация\" (ведется рестр). Ниже приводятся 2 способа создания экземпляра класса \"Платеж\". Верхний рисунок - с использованием паттерна \"Создатель\", нижний - с использованием \"Низкая связанность\". Последний способ обеспечивает более низкую степень связывания.', '1226b0a80af0915bd1b6312b38e5db8a.gif', 2, 2);
INSERT INTO `article` (`id`, `title`, `content`, `image`, `author_id`, `category_id`) VALUES
(30, 'High Cohesion', 'Проблема<br>	Необходимо обеспечить выполнение объектами разнородных функций.\r\n<br>Решение<br>	Обеспечить распределение обязанностей с высоким зацеплением.\r\n<br>Пример<br>	Если в примере для паттерна \"Низкая связанность\" на класс \"Регистрация\" возлагать все новые и новые системные функции, связанные с системными операциями, то данный класс будет слишком перегружен и будет обладать низкой степенью зацепления. Второй рисунок для примера Low Coupling обладает более высоким уровнем зацепления и низким уровнем связывания (он является более предпочтительным).\r\n<br>Преимущества<br>	Классы с высокой степенью зацепления просты в поддержке и повторном использовании.\r\n<br>Недостатки<br>	Иногда бывает неоправданно использовать высокое зацепление для распределенных серверных обьектов. В этом случае для обеспечения быстродействия необходимо создать несколько более крупных серверных обьектов со слабым зацеплением.', '8bbc079611ba63c0fb2effb6ac6e3c23.gif', 2, 3),
(31, 'Controller', 'Проблема<br>	\"Кто\" должен отвечать за обработку входных системных событий?\r\n<br>Решение<br>	Обязанности по обработке системных сообщений делегируются специальному классу. Контроллер - это объект, который отвечает за обработку системных событий и не относится к интерфейсу пользователя. Контроллер определяет методы для выполнения системных операций.\r\n<br>Рекомендации<br>	Для различных прецедентов логично использовать разные контроллеры (контроллеры прецедентов) - контроллеры не должны быть перегружены. Внешний контроллер представляет всю систему целиком, его можно использовать, если он будет не слишком перегруженным (то есть, если существует лишь несколько системных событий).\r\n<br>Преимущества<br>	Удобно накапливать информацию о системных событиях (в случае, если системные операции выполняются в некоторой определенной последовательности). Улучшаются условия для повторного использования компонентов (системные события обрабатываются Контроллером а не элементами интерфейса пользователя).\r\n<br>Недостатки<br>	Контроллер может оказаться перегружен.', '16f50dff254fd44768b46caf204f40fe.jpg', 2, 3),
(32, 'Polymorphism', 'Проблема<br>	Как обрабатывать альтернативные варианты поведения на основе типа? Как заменять подключаемые компоненты системы?\r\nРешение	Обязанности распределяются для различных вариантов поведения с помощью полиморфных операций для этого класса. Каждая внешняя система имеет свой интерфейс.\r\n<br>Пример<br>	Интеграция разрабатываемой системы с различными внешними системами учета налогов. Используются локальные программные объекты, обеспечивающие адаптацию (Адаптеры), при отправке сообщения к такому объекту выполняется обращение к внешней системе с использованием ее собственного программного интерфейса.\r\n Использование полиморфизма оправдано для адаптации к различным внешним системам.\r\n<br>Преимущества<br>	Впоследствии легко расширять и модернизировать систему.\r\n<br>Недостатки<br>	Не следует злоупотреблять добавлением интерфейсов с применением принципа полиморфизма с целью обеспечения дееспособности системы в неизвестных заранее новых ситуациях.', '4aa012fc1990e5bebe34c25b4672294d.gif', 2, 3),
(33, 'Indirection', 'Проблема Как перераспределить обязанности обьектов, чтобы обеспечить отсутствие прямого связывания?\r\nРешение	Присвоить обязанности по обеспечению связи между службами или компонентами промежуточному объекту.', 'c3ef2c417bf780bd1ccceffffa7568d7.jpg', 2, 3),
(34, 'Protected Variations', 'Проблема Как спроектировать систему так, чтобы изменение одних ее элементов не влияло на другие?\r\nРешение	Идентифицировать точки возможных изменений или неустойчивости и распределить обязанности таким образом, чтобы обеспечить устойчивую работу системы.', '13abfcf05a46c9bbd6e63c5181875d48.jpg', 2, 2),
(35, 'Single Responsibility', 'Термин SRP был введён Робертом С. Мартином в одноименной статье как часть SOLID, ставших популярными благодаря его книге \"Быстрая разработка программ. Принципы, примеры, практика.\". Мартин описал SRP, основываясь на закономерности, описанной Томом ДеМарко[2] и Мейлиром Пейдж-Джонсом и названной связностью.\r\n\r\nВ SOLID — буква «S» является аббревиатурой, которая образована сокращением от английского названия принципа единственной ответственности.\r\n\r\nМартин определяет ответственность как причину изменения и заключает, что классы должны иметь одну и только одну причину для изменений. Например, представьте себе класс, который составляет и печатает отчёт. Такой класс может измениться по двум причинам:\r\n\r\nможет измениться само содержимое отчёта\r\nможет измениться формат отчёта.\r\nЛогично, что оба аспекта этих причин на самом деле являются двумя разными ответственностями. SRP говорит, что в таком случае нужно разделить класс на два новых класса, для которых будет характерна только одна ответственность. Причина, почему нужно сохранять направленность классов на единственную цель в том, что это делает классы более здоровыми. Что касается класса, приведённого выше, если произошло изменение в процессе составления отчёта — есть большая вероятность, что в негодность придёт код, отвечающий за печать.\r\n\r\nПри разработке различных поведений одного класса часто появляется \"Божественный объект\", который в ООП считается антипаттерном. Соблюдение принципа единственной ответственности позволяет избегать этот антипаттерн.\r\n\r\nИспользование\r\nВозникает вопрос, когда стоит использовать этот принцип? Всё же принцип - это не закон и SRP стоит применять в зависимости от того, как изменяется приложение:\r\n\r\nесли при изменении кода, отвечающего за одну ответственность, в приложении появляются исправления кода, отвечающего за другую ответственность, то это первый сигнал о нарушении SRP.\r\nесли же изменения кода, отвечающего за одну ответственность, не вносят изменения в код, отвечающий за другую ответственность, то этот принцип можно не применять.\r\n\r\nПример класса, который подаёт признаки нарушении SRP принципа.\r\nСлепое следование принципу единственной ответственности приводит к избыточной сложности приложения, его поддержки и тестированию. SRP стоит применять только тогда, когда это оправдано. Например, приложение, в котором используется ActiveRecord - паттерн, который позволяет легко связать данные объектов и данные из базы данных. При ActiveRecord много ответственностей сконцентрировано в одном месте и поэтому можно утверждать, что ActiveRecord нарушает SRP и тем самым становится антипаттерном. Принцип SRP можно применить только в том случае, когда:\r\n\r\nобъекту класса становится позволительно слишком много;\r\nдоменная логика концентрируется только в одном классе;\r\nлюбое изменение логики поведения объекта приводит к изменениям в других местах приложения, где это не подразумевалось изначально;\r\nприходится тестировать, исправлять ошибки, компилировать различные места приложения, даже если за их работоспособность отвечает третья сторона;\r\nневозможно легко отделить и применить класс в другой сфере приложения, так как это потянет ненужные зависимости.\r\n\r\nВроде классы разделены по назначениям, но у Response есть признак нарушения SRP. Он зависим от Report. Изменяя Report, например, удалив метод получения заголовка, потребуются внести изменения в Response. А ведь изначально не подразумевалось изменять код формата отчёта. Код проекта не готов к быстрым и безболезненным изменениям.\r\nОбъединение ответственностей является общепринятой практикой и в этом нет ничего плохого, до тех пор пока это легко обслуживать. Следование принципу единой ответственности зависит от функций программного продукта и является труднейшим при проектировании приложений.\r\n\r\nПриёмы соблюдения принципа\r\nСледующие приёмы позволяют соблюдать принцип единственной ответственности:\r\n\r\nРазработка через тестирование\r\nШаблон «Выделение класса»\r\nШаблон «Фасад»\r\nШаблон «Proxy»\r\nDAO\r\nКлассическим примером нарушения SRP может служить ситуация, когда системе с бизнес-правилами (BRMS) нужно иметь дело с постоянным хранилищем (Persistence[en]). На первых этапах проектирования таких систем создаётся класс, который обрабатывает бизнес правила и содержит логику работы с базой данных. С нарушением SRP появляются признаки плохого проекта, такие как:\r\n\r\nсистема с трудом поддается изменениям, поскольку любое минимальное изменение вызывает эффект «снежного кома», затрагивающего другие компоненты системы.\r\nв результате осуществляемых изменений система разрушается в тех местах, которые не имеют прямого отношения к непосредственно изменяемому компоненту.\r\nЕсли бы система изначально разрабатывалась через тестирование(TDD), то этой проблемы могло бы и не возникнуть. Опираясь на тесты, разработчики могут быстрее представить, какая функциональность необходима пользователю. Таким образом, детали класса появляются задолго до окончательной реализации решения, тем самым влияя на дизайн разрабатываемой системы. Но бывает и так, что разработка через тестирование не приводит к применению шаблона «Выделение класса», тогда к системе применяется рефакторинг с применением шаблонов «Фасад», DAO или «Proxy».\r\n\r\nSRP предлагает разделять универсальные классы на конкретные, что сделает их простыми и лёгкими в обслуживании. Подобную идею также выдвигает принцип KISS.', '1cd7aeef1e3ae99e40000a04b6053e4e.png', 3, 5),
(36, 'Open Closed', 'Описание\r\nПринцип OCP означает, что программные сущности должны быть:\r\nоткрыты для расширения: означает, что поведение сущности может быть расширено, путём создания новых типов сущностей.\r\nзакрыты для изменения: в результате расширения поведения сущности, не должны вноситься изменения в код, который эти сущности используют.\r\nЭто особенно значимо в производственной среде, когда изменения в исходном коде потребуют проведение пересмотра кода, модульного тестирования и других подобных процедур, чтобы получить право на использования его в программном продукте. Код, подчиняющийся данному принципу, не изменяется при расширении и поэтому не требует таких трудозатрат.\r\nТермин «принцип открытости/закрытости» имеет два значения:\r\nПринцип открытости/закрытости Мейера\r\nПолиморфный принцип открытости/закрытости\r\nОба значения используют наследование для решения дилеммы, но цели, способы и результаты — различны.\r\nПринцип открытости/закрытости Мейера\r\nБертран Мейер в основном известен как основоположник термина Принцип открытости/закрытости, который появился в 1988 году в его книге Object-Oriented Software Construction, , отвечая на вопрос:\r\n\"Как можно разработать проект, устойчивый к изменениям, срок жизни которых превышает срок существования первой версии проекта?\".\r\nИдея была в том, что однажды разработанная реализация класса в дальнейшем требует только исправления ошибок, а новые или изменённые функции требуют создания нового класса. Этот новый класс может переиспользовать код исходного класса через механизм наследования. Производный подкласс может реализовывать или не реализовывать интерфейс исходного класса.\r\nОпределение Мейера поддерживает идею наследования реализации. Реализация может быть переиспользована через наследование, но спецификации интерфейса могут измениться. Существующая реализация должна быть закрыта для изменений, но новые реализации не обязаны использовать существующий интерфейс.\r\nПолиморфный принцип открытости/закрытости\r\nВ течение 1990-х принцип открытости/закрытости стал де-факто переопределён для применения с абстрактными интерфейсами, реализации которых могут быть изменены, и могут быть созданы множественные реализации и полиморфно замещены одна на другую.\r\nВ противоположность применения Мейером, это определение поддерживает идею наследования от абстрактных базовых классов. Спецификации интерфейсов могут быть переиспользованы через наследование, но реализации изменяться не должны. Существующий интерфейс должен быть закрыт для модификаций, а новые реализации должны, по меньшей мере, реализовывать этот интерфейс.\r\nСтатья Роберта С. Мартина «The Open-Closed Principle» в 1996 была одной из плодотворных статей для популяризации такого подхода. В 2001 году Крэйг Ларман отнёс термин Принцип открытости/закрытости к шаблону Алистэра Кокбёрна (Alistair Cockburn), названного Protected Variations, и к обсуждению с Дэвидом Парнасом (David Parnas) о скрытии информации', '04dfaea05d7e413b793c26c1c1360668.jpg', 3, 5),
(37, 'Dependency Inversion', 'Принцип инверсии зависимостей (англ. dependency inversion principle, DIP)\r\n\r\nМодули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.\r\nАбстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.', '24807727749c8e0e71fa6a49f581c606.jpg', 3, 5),
(38, 'Liskov Substitution', 'Принцип подстановки Барбары Лисков\r\n\r\nПринцип подстановки Барбары Лисков (англ. Liskov Substitution Principle, LSP) в объектно-ориентированном программировании является специфичным определением подтипа, предложенным Барбарой Лисков в 1987 году на конференции в основном докладе под названием Абстракция данных и иерархия\r\n\r\nВ последующей статье Лисков кратко сформулировала свой принцип следующим образом:\r\n\r\nПусть {\\displaystyle q(x)} q(x) является свойством, верным относительно объектов {\\displaystyle x} x некоторого типа {\\displaystyle T} T. Тогда {\\displaystyle q(y)} q(y) также должно быть верным для объектов {\\displaystyle y} y типа {\\displaystyle S} S, где {\\displaystyle S} S является подтипом типа {\\displaystyle T} T.\r\nРоберт С. Мартин определил этот принцип так:\r\n\r\nФункции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.\r\nТаким образом, идея Лисков о «подтипе» даёт определение понятия замещения — если S является подтипом T, тогда объекты типа T в программе могут быть замещены объектами типа S без каких-либо изменений желательных свойств этой программы (например, корректность).\r\n\r\nЭтот принцип является важнейшим критерием для оценки качества принимаемых решений при построении иерархий наследования. Сформулировать его можно в виде простого правила: тип S будет подтипом Т тогда и только тогда, когда каждому объекту oS типа S соответствует некий объект oT типа T таким образом, что для всех программ P, реализованных в терминах T, поведение P не будет меняться, если oT заменить на oS.\r\n\r\nБолее простыми словами можно сказать, что поведение наследуемых классов не должно противоречить поведению, заданному базовым классом, то есть поведение наследуемых классов должно быть ожидаемым для кода, использующего переменную базового типа.\r\n\r\nСаттер и Александреску в своём руководстве по использованию C++ для выражения этого принципа также используют фразу «подкласс не должен требовать от вызывающего кода больше, чем базовый класс, и не должен предоставлять вызывающему коду меньше, чем базовый класс». По мнению данных авторов, публичное наследование в C++ можно употреблять только тогда, когда оно удовлетворяет принципу Лисков. Приватное наследование, по их же мнению, дозволено использовать для доступа к protected части базы и перекрытия виртуальных методов. В любом же ином случае, то есть для всего лишь повторного использования кода из базы, наследование применять нельзя.\r\n\r\nОснования: использование публичного наследования для повторного использования кода приводит к тому, что внешний мир начинает считать класс Derived разновидностью класса Base, и возможно появление кода, явно использующего этот факт. Это сильно сужает простор для манёвра архитектора в дальнейшем поддержании и рефакторинге класса Derived.\r\n\r\nПроектирование по контракту\r\nПринцип подстановки (замещения) Лисков имеет близкое отношение к методологии контрактного программирования, и ведёт к некоторым ограничениям на то, как контракты могут взаимодействовать с наследованием:\r\n\r\nПредусловия не могут быть усилены в подклассе.\r\nПостусловия не могут быть ослаблены в подклассе.\r\nТакже принцип LSP подразумевает, что методы подкласса не могут генерировать никаких дополнительных исключений, кроме тех, которые сами являются подклассами исключений, генерируемых методами надкласса. См. Ковариантность и контравариантность и типы данных.\r\n\r\nФункция, использующая иерархию классов с нарушениями принципа Лисков, помимо оперирования ссылкой на базовый класс, оказывается также вынуждена знать и о подклассе. Подобная функция нарушает принцип открытости/закрытости, поскольку она требует модификации в случае появления в системе новых производных классов.\r\n\r\nВ данном контексте принцип подстановки можно переформулировать следующим образом:\r\n\r\nФункции, которые используют ссылки на базовые классы, должны иметь возможность использовать объекты производных классов, не зная об этом.\r\nПринцип Барбары Лисков заставляет задуматься о том, что такое «декларация типа» в терминах объектно-ориентированного языка программирования, который мы используем. Достаточно ли нам описать интерфейс объекта с помощью обычного абстрактного класса со списком методов, типами параметров и возвращаемого значения? Каким образом мы можем декларировать требования к значениям параметров метода и свойства, которыми будет обладать возвращаемое значение? Как нам описать исключения, которые может сгенерировать метод во время выполнения? Как нам описать изменение состояния объекта на разных этапах его жизненного цикла?\r\n\r\nЗадавая себе эти вопросы и находя ответы, можно спроектировать систему, которая действительно будет удовлетворять принципу подстановки Барбары Лисков.', '45d745714690f470f91abb0728f938dd.jpg', 3, 5),
(39, 'Interface Segregation', 'Принцип разделения интерфейсов говорит о том, что слишком «толстые» интерфейсы необходимо разделять на более маленькие и специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе. В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.', '51a2ce98ffa7c10f4f53be2847555a02.jpg', 3, 5),
(40, 'MVC', 'Model-View-Controller (MVC, «Модель-Представление-Контроллер», «Модель-Вид-Контроллер») — схема разделения данных приложения, пользовательского интерфейса и управляющей логики на три отдельных компонента: модель, представление и контроллер — таким образом, что модификация каждого компонента может осуществляться независимо\r\n\r\nМодель (Model) предоставляет данные и реагирует на команды контроллера, изменяя свое состояние\r\nПредставление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели\r\nКонтроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений\r\nВпервые описан норвежцем Трюгве Ринскаугом в 1978 году\r\n\r\nКонцепция MVC была описана Трюгве Реенскаугом в 1978 году, работавшем в научно-исследовательском центре «Xerox PARC» над языком программирования «Smalltalk». Позже, Стив Бурбек реализовал шаблон в Smalltalk-80\r\n\r\nОкончательная версия концепции MVC была опубликована лишь в 1988 году в журнале Technology Object\r\n\r\nВпоследствии, шаблон проектирования стал эволюционировать. Например, была представлена иерархическая версия HMVC; MVA, MVVM\r\n\r\nПосле внедрения компанией Apple технологии WebObjects, реализованных на Objective-C, стало популяризировать шаблон и в вебе\r\n\r\nКогда WebObjects портировали на Java, шаблон стал популярен и там. Более поздние фреймворки вроде Spring (октябрь 2002 года) всё ещё имеют реализацию MVC\r\n\r\nДальнейший виток популярности привнесло развитие фреймворков, ориентированных на быструю развёртку, на языках Python и Ruby, Django и Rails, соответственно. На момент 2017 года, фреймворки с MVC заняли заметные позиции по отношению к остальным фреймворкам без этого шаблона\r\n\r\nРазличия описания концепции шаблона\r\nС развитием объектно-ориентированного программирования и понятия о шаблонах проектирования — был создан ряд модификаций концепции MVC, которые при реализации у разных авторов могут отличаться от оригинальной. Так, например, Эриан Верми в 2004 году описал пример обобщённого MVC\r\n\r\nВ предисловии к диссертации «Naked objects» Ричарда Поусона (Richard Pawson), — Трюгве Реенскауг упоминает свою неопубликованную наиболее раннюю версию MVC, согласно которой\r\n\r\nМодель относилась к «разуму» пользователя;\r\nПод представлением имелся в виду редактор, позволяющий пользователю просматривать и обновлять информацию;\r\nКонтроллер являлся инструментом для связывания представлений воедино и применялся пользователем для решения его задач.\r\n\r\nНазначение\r\nОсновная цель применения этой концепции состоит в отделении бизнес-логики (модели) от её визуализации (представления, вида). За счёт такого разделения повышается возможность повторного использования кода. Наиболее полезно применение данной концепции в тех случаях, когда пользователь должен видеть те же самые данные одновременно в различных контекстах и/или с различных точек зрения. В частности, выполняются следующие задачи:\r\n\r\nК одной модели можно присоединить несколько видов, при этом не затрагивая реализацию модели. Например, некоторые данные могут быть одновременно представлены в виде электронной таблицы, гистограммы и круговой диаграммы;\r\nНе затрагивая реализацию видов, можно изменить реакции на действия пользователя (нажатие мышью на кнопке, ввод данных) — для этого достаточно использовать другой контроллер;\r\nРяд разработчиков специализируется только в одной из областей: либо разрабатывают графический интерфейс, либо разрабатывают бизнес-логику. Поэтому возможно добиться того, что программисты, занимающиеся разработкой бизнес-логики (модели), вообще не будут осведомлены о том, какое представление будет использоваться.\r\n\r\nКонцепция MVC позволяет разделить модель, представление и контроллер на три отдельных компонента:\r\n\r\nМодель\r\nМодель предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность. Модель не зависит от представления — не знает как данные визуализировать — и контроллера — не имеет точек взаимодействия с пользователем —, просто предоставляя доступ к данным и управлению ими.\r\n\r\nМодель строится таким образом, чтобы отвечать на запросы, изменяя своё состояние, при этом может быть встроено уведомление «наблюдателей».\r\n\r\nМодель, за счёт независимости от визуального представления, может иметь несколько различных представлений для одной «модели».\r\n\r\nПредставление\r\nПредставление отвечает за получение необходимых данных из модели и отправляет их пользователю. Представление не обрабатывает введённые данные пользователя\r\n\r\nПредставление может влиять на состояние модели сообщая модели об этом.\r\n\r\nКонтроллер\r\nКонтроллер обеспечивает «связи» между пользователем и системой. Контролирует и направляет данные от пользователя к системе и наоборот. Использует модель и представление для реализации необходимого действия.\r\n\r\nФункциональные возможности и расхождения\r\nПоскольку MVC не имеет строгой реализации, то реализован он может быть по-разному. Нет общепринятого определения, где должна располагаться бизнес-логика. Она может находиться как в контроллере, так и в модели. В последнем случае, модель будет содержать все бизнес-объекты со всеми данными и функциями.\r\n\r\nНекоторые фреймворки жестко задают где должна располагаться бизнес-логика, другие не имеют таких правил.\r\n\r\nТакже не указано, где должна находиться проверка введённых пользователем данных. Простая валидация может встречаться даже в представлении, но чаще они встречаются в контроллере или модели.\r\n\r\nИнтернационализация и форматирование данных также не имеет четких указаний по расположению.', 'a0058ce74ae71905e51426a0165918f9.png', 4, 4),
(41, 'Active Record', 'Active record (AR) — шаблон проектирования приложений, описанный Мартином Фаулером в книге Patterns of Enterprise Application Architecture («Шаблоны архитектуры корпоративных приложений»). AR является популярным способом доступа к данным реляционных баз данных в объектно-ориентированном программировании.\r\n\r\nОбщий принцип работы\r\nПусть существует таблица в базе данных. Для данной таблицы создаётся специальный класс AR, являющийся отражением (представлением) таблицы, таким образом, что:\r\n\r\nкаждый экземпляр данного класса соответствует одной записи таблицы;\r\nпри создании нового экземпляра класса (и заполнении соответствующих полей) в таблицу добавляется новая запись;\r\nпри чтении полей объекта считываются соответствующие значения записи таблицы баз данных;\r\nпри изменении (удалении) какого-либо объекта изменяется (удаляется) соответствующая ему запись.', 'd9e377b145b2bb011e2e07e64c7b84ed.png', 5, 4),
(42, 'Bad Project Signs', 'Признаки плохого проекта\r\nЗакрепощённость: система с трудом поддается изменениям, поскольку любое минимальное изменение вызывает эффект \"снежного кома\", затрагивающего другие компоненты системы.\r\nНеустойчивость: в результате осуществляемых изменений система разрушается в тех местах, которые не имеют прямого отношения к непосредственно изменяемому компоненту.\r\nНеподвижность: достаточно трудно разделить систему на компоненты, которые могли бы повторно использоваться в других системах.\r\nВязкость: сделать что-то правильно намного сложнее, чем выполнить какие-либо некорректные действия.\r\nНеоправданная сложность: проект включает инфраструктуру, применение которой не влечёт непосредственной выгоды.\r\nНеопределенность: проект трудно читать и понимать. Недостаточно четко выражено содержимое проекта.', '01eb38049f6540ec523e65bef0642457.jpg', NULL, 4),
(43, 'Object Relational Mapping', 'ORM (англ. Object-Relational Mapping, рус. объектно-реляционное отображение) — технология программирования, которая связывает базы данных с концепциями объектно-ориентированных языков программирования, создавая «виртуальную объектную базу данных». Существуют как проприетарные, так и свободные реализации этой технологии.\r\n\r\nЗадача\r\nНеобходимо обеспечить работу с данными в терминах классов, а не таблиц данных и напротив, преобразовать термины и данные классов в данные, пригодные для хранения в СУБД. Необходимо также обеспечить интерфейс для CRUD-операций над данными. В общем, необходимо избавиться от необходимости писать SQL-код для взаимодействия в СУБД\r\n\r\nРеляционные СУБД\r\nРешение проблемы хранения данных существует — это реляционные системы управления базами данных. Использование реляционной базы данных для хранения объектно-ориентированных данных приводит к семантическому разрыву, заставляя программистов писать программное обеспечение, которое должно уметь как обрабатывать данные в объектно-ориентированном виде, так и уметь сохранить эти данные в реляционной форме. Эта постоянная необходимость в преобразовании между двумя разными формами данных не только сильно снижает производительность, но и создает трудности для программистов, так как обе формы данных накладывают ограничения друг на друга.\r\n\r\nРеляционные базы данных используют набор таблиц, представляющих простые данные. Дополнительная или связанная информация хранится в других таблицах. Часто для хранения одного объекта в реляционной базе данных используется несколько таблиц; это, в свою очередь, требует применения операции JOIN для получения всей информации, относящейся к объекту, для её обработки. Например, для хранения данных записной книжки, скорее всего, будут использоваться как минимум две таблицы: люди и адреса, и, возможно, даже таблица с телефонными номерами.\r\n\r\nТак как системы управления реляционными базами данных обычно не реализуют реляционного представления физического уровня связей, выполнение нескольких последовательных запросов (относящихся к одной «объектно-ориентированной» структуре данных) может быть слишком затратно. В частности, один запрос вида «найти такого-то пользователя и все его телефоны и все его адреса и вернуть их в таком формате», скорее всего, будет выполнен быстрее серии запросов вида «Найти пользователя. Найти его адреса. Найти его телефоны». Это происходит благодаря работе оптимизатора и затратам на синтаксический анализ запроса.\r\n\r\nНекоторые реализации ORM автоматически синхронизируют загруженные в память объекты с базой данных. Для того чтобы это было возможным, после создания объект-в-SQL-преобразующего SQL-запроса (класса, реализующего связь с DB) полученные данные копируются в поля объекта, как во всех других реализациях ORM. После этого объект должен следить за изменениями этих значений и записывать их в базу данных.\r\n\r\nСистемы управления реляционными базами данных показывают хорошую производительность на глобальных запросах, которые затрагивают большой участок базы данных, но объектно-ориентированный доступ более эффективен при работе с малыми объёмами данных, так как это позволяет сократить семантический провал между объектной и реляционной формами данных.\r\n\r\nПри одновременном существовании этих двух разных миров увеличивается сложность объектного кода для работы с реляционными базами данных, и он становится более подвержен ошибкам. Разработчики программного обеспечения, основывающегося на базах данных, искали более легкий способ достижения постоянства их объектов.\r\n\r\nРешение\r\nРазработано множество пакетов, устраняющих необходимость в преобразовании объектов для хранения в реляционных базах данных.\r\n\r\nНекоторые пакеты решают эту проблему, предоставляя библиотеки классов, способных выполнять такие преобразования автоматически. Имея список таблиц в базе данных и объектов в программе, они автоматически преобразуют запросы из одного вида в другой. В результате запроса объекта «человек» (из примера с адресной книгой) необходимый SQL-запрос будет сформирован и выполнен, а результаты «волшебным» образом преобразованы в объекты «номер телефона» внутри программы.\r\n\r\nС точки зрения программиста система должна выглядеть как постоянное хранилище объектов. Он может просто создавать объекты и работать с ними как обычно, а они автоматически будут сохраняться в реляционной базе данных.\r\n\r\nНа практике всё не так просто и очевидно. Все системы ORM обычно проявляют себя в том или ином виде, уменьшая в некотором роде возможность игнорирования базы данных. Более того, слой транзакций может быть медленным и неэффективным (особенно в терминах сгенерированного SQL). Все это может привести к тому, что программы будут работать медленнее и использовать больше памяти, чем программы, написанные «вручную».\r\n\r\nНо ORM избавляет программиста от написания большого количества кода, часто однообразного и подверженного ошибкам, тем самым значительно повышая скорость разработки. Кроме того, большинство современных реализаций ORM позволяют программисту при необходимости самому жёстко задать код SQL-запросов, который будет использоваться при тех или иных действиях (сохранение в базу данных, загрузка, поиск и т. д.) с постоянным объектом.', '8f5a7f6f485ed086df519f9582008a20.jpg', NULL, 4);

-- --------------------------------------------------------

--
-- Table structure for table `author`
--

CREATE TABLE `author` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `description` varchar(500) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `author`
--

INSERT INTO `author` (`id`, `name`, `description`) VALUES
(1, 'GOF', 'Design Patterns: <br>\r\nElements of Reusable Object-Oriented Software <br>\r\nAuthor	The \"Gang of Four\": <br>\r\nErich Gamma, <br>\r\nRichard Helm, <br>\r\nRalph Johnson,<br>\r\nJohn Vlissides<br>\r\nCountry	USA<br>\r\nPublisher Addison-Wesley<br>\r\nPublication date 1994'),
(2, 'GRASP', 'General Responsibility Assignment Software Principles by Craig Larman'),
(3, 'SOLID', 'single responsibility, open-closed, Liskov substitution, interface segregation and dependency inversion is a mnemonic acronym introduced by Michael Feathers for the \"first five principles\" named by Robert C. Martin'),
(4, 'Trygve Reenskaug', 'Trygve Reenskaug introduced MVC into Smalltalk-76 while visiting the Xerox Palo Alto Research Center (PARC) in the 1970s. In the 1980s, Jim Althoff and others implemented a version of MVC for the Smalltalk-80 class library. Only later did a 1988 article in The Journal of Object Technology (JOT) express MVC as a general concept'),
(5, 'Martin Fowler', 'In software engineering, the active record pattern is an architectural pattern found in software that stores in-memory object data in relational databases. It was named by Martin Fowler in his 2003 book Patterns of Enterprise Application Architecture. The interface of an object conforming to this pattern would include functions such as Insert, Update, and Delete, plus properties that correspond more or less directly to the columns in the underlying database table.');

-- --------------------------------------------------------

--
-- Table structure for table `category`
--

CREATE TABLE `category` (
  `id` int(11) NOT NULL,
  `title` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `category`
--

INSERT INTO `category` (`id`, `title`) VALUES
(1, 'Creational'),
(2, 'Structural'),
(3, 'Behavioral'),
(4, 'Architectural'),
(5, 'NoCategory');

-- --------------------------------------------------------

--
-- Table structure for table `migration`
--

CREATE TABLE `migration` (
  `version` varchar(180) NOT NULL,
  `apply_time` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `migration`
--

INSERT INTO `migration` (`version`, `apply_time`) VALUES
('m000000_000000_base', 1494090240),
('m170504_135030_create_article_table', 1494090265),
('m170504_135051_create_user_table', 1494090266),
('m170506_165035_create_category_table', 1494090266),
('m170507_093942_create_author_table', 1494150105);

-- --------------------------------------------------------

--
-- Table structure for table `user`
--

CREATE TABLE `user` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `password` varchar(255) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `user`
--

INSERT INTO `user` (`id`, `name`, `password`) VALUES
(1, 'user', 'password');

--
-- Indexes for dumped tables
--

--
-- Indexes for table `article`
--
ALTER TABLE `article`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `author`
--
ALTER TABLE `author`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `category`
--
ALTER TABLE `category`
  ADD PRIMARY KEY (`id`);

--
-- Indexes for table `migration`
--
ALTER TABLE `migration`
  ADD PRIMARY KEY (`version`);

--
-- Indexes for table `user`
--
ALTER TABLE `user`
  ADD PRIMARY KEY (`id`);

--
-- AUTO_INCREMENT for dumped tables
--

--
-- AUTO_INCREMENT for table `article`
--
ALTER TABLE `article`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=44;
--
-- AUTO_INCREMENT for table `author`
--
ALTER TABLE `author`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;
--
-- AUTO_INCREMENT for table `category`
--
ALTER TABLE `category`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=6;
--
-- AUTO_INCREMENT for table `user`
--
ALTER TABLE `user`
  MODIFY `id` int(11) NOT NULL AUTO_INCREMENT, AUTO_INCREMENT=2;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
